
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Neurodata Without Borders: Neurophysiology (NWB:N), Extracellular Electrophysiology Tutorial</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-12-17"><meta name="DC.source" content="ecephys.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Neurodata Without Borders: Neurophysiology (NWB:N), Extracellular Electrophysiology Tutorial</h1><!--introduction--><p>How to write ecephys data to an NWB file using matnwb.</p><pre>author: Ben Dichter
contact: ben.dichter@gmail.com
last edited: Oct 9, 2018</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">NWB file</a></li><li><a href="#3">Data dependencies</a></li><li><a href="#5">Electrode Table</a></li><li><a href="#7">LFP</a></li><li><a href="#10">Trials</a></li><li><a href="#12">Processing Modules</a></li><li><a href="#13">Spikes</a></li><li><a href="#17">Writing the file</a></li><li><a href="#18">Reading the file</a></li><li><a href="#19">Reading data</a></li><li><a href="#23">Reading UnitTimes (RegionViews)</a></li></ul></div><h2 id="1">NWB file</h2><p>All contents get added to the NWB file, which is created with the following command</p><pre class="codeinput">date = datetime(2018, 3, 1, 12, 0, 0);
session_start_time = datetime(date,<span class="string">'Format'</span>,<span class="string">'yyyy-MM-dd''T''HH:mm:SSZZ'</span>,<span class="keyword">...</span>
    <span class="string">'TimeZone'</span>,<span class="string">'local'</span>);
nwb = nwbfile( <span class="string">'source'</span>, <span class="string">'acquired on rig2'</span>, <span class="keyword">...</span>
    <span class="string">'session_description'</span>, <span class="string">'a test NWB File'</span>, <span class="keyword">...</span>
    <span class="string">'identifier'</span>, <span class="string">'mouse004_day4'</span>, <span class="keyword">...</span>
    <span class="string">'session_start_time'</span>, session_start_time);
</pre><p>You can check the contents by displaying the nwbfile object</p><pre class="codeinput">disp(nwb);
</pre><pre class="codeoutput">  nwbfile with properties:

                        nwb_version: '2.0b'
                        acquisition: [1&times;1 types.untyped.Set]
                           analysis: [1&times;1 types.untyped.Set]
                   file_create_date: []
            general_data_collection: []
                    general_devices: [1&times;1 types.untyped.Set]
     general_experiment_description: []
               general_experimenter: []
        general_extracellular_ephys: [1&times;1 types.untyped.Set]
                general_institution: []
        general_intracellular_ephys: [1&times;1 types.untyped.Set]
                   general_keywords: []
                        general_lab: []
                      general_notes: []
               general_optogenetics: [1&times;1 types.untyped.Set]
             general_optophysiology: [1&times;1 types.untyped.Set]
               general_pharmacology: []
                   general_protocol: []
       general_related_publications: []
                 general_session_id: []
                     general_slices: []
              general_source_script: []
    general_source_script_file_name: []
             general_specifications: [1&times;1 types.untyped.Set]
                   general_stimulus: []
                    general_subject: []
                    general_surgery: []
                      general_virus: []
                         identifier: 'mouse004_day4'
                          intervals: [1&times;1 types.untyped.Set]
                         processing: [1&times;1 types.untyped.Set]
                session_description: 'a test NWB File'
                 session_start_time: 2018-03-01T12:00:00-0500
              stimulus_presentation: [1&times;1 types.untyped.Set]
                 stimulus_templates: [1&times;1 types.untyped.Set]
          timestamps_reference_time: []
                              units: []
                               help: 'an NWB:N file for storing cellular-based neurophysiology data'

</pre><h2 id="3">Data dependencies</h2><p>The data needs to be added to nwb in a specific order, which is specified by the data dependencies in the schema. The data dependencies for LFP are illustrated in the following diagram. In order to write LFP, you need to specify what electrodes it came from. To do that, you first need to construct an electrode table.</p><p><img vspace="5" hspace="5" src="ecephys_data_deps.png" alt=""> </p><h2 id="5">Electrode Table</h2><p>Electrode tables hold the position and group information about each electrode and the brain region and filtering. Groups organize electrodes within a single device. Devices can have 1 or more groups. In this example, we have 2 devices that each only have a single group.</p><pre class="codeinput">device_labels = {<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>};

udevice_labels = unique(device_labels, <span class="string">'stable'</span>);

variables = {<span class="string">'id'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'imp'</span>, <span class="string">'location'</span>, <span class="string">'filtering'</span>, <span class="keyword">...</span>
    <span class="string">'group'</span>, <span class="string">'group_name'</span>};
<span class="keyword">for</span> i_device = 1:length(udevice_labels)
    device_label = udevice_labels{i_device};

    nwb.general_devices.set(device_label,<span class="keyword">...</span>
        types.core.Device());

    nwb.general_extracellular_ephys.set(device_label,<span class="keyword">...</span>
        types.core.ElectrodeGroup(<span class="keyword">...</span>
        <span class="string">'description'</span>, <span class="string">'a test ElectrodeGroup'</span>, <span class="keyword">...</span>
        <span class="string">'location'</span>, <span class="string">'unknown'</span>, <span class="keyword">...</span>
        <span class="string">'device'</span>, types.untyped.SoftLink([<span class="string">'/general/devices/'</span> device_label])));

    ov = types.untyped.ObjectView([<span class="string">'/general/extracellular_ephys/'</span> device_label]);

    elec_nums = find(strcmp(device_labels, device_label));
    <span class="keyword">for</span> i_elec = 1:length(elec_nums)
        elec_num = elec_nums(i_elec);
        <span class="keyword">if</span> i_device == 1 &amp;&amp; i_elec == 1
            tbl = table(int64(1), NaN, NaN, NaN, NaN, {<span class="string">'CA1'</span>}, {<span class="string">'filtering'</span>}<span class="keyword">...</span>
                , ov, {<span class="string">'electrode_group'</span>},<span class="string">'VariableNames'</span>, variables);
        <span class="keyword">else</span>
            tbl = [tbl; {int64(elec_num), NaN, NaN, NaN, NaN,<span class="keyword">...</span>
                <span class="string">'CA1'</span>, <span class="string">'filtering'</span>, ov, <span class="string">'electrode_group'</span>}];
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>add the <tt>DynamicTable</tt> object to the NWB file using the name <tt>'electrodes'</tt> (not flexible)</p><pre class="codeinput">tbl.Properties.Description = <span class="string">'my description'</span>;

electrode_table = util.table2nwb(tbl);
nwb.general_extracellular_ephys.set(<span class="string">'electrodes'</span>, electrode_table);
</pre><h2 id="7">LFP</h2><p>In order to write LFP, you need to construct a region view of the electrode table to link the signal to the electrodes that generated them. You must do this even if the signal is from all of the electrodes. Here we will create a reference that includes all electrodes. Then we will randomly generate a signal 1000 timepoints long from 10 channels</p><pre class="codeinput">ov = types.untyped.ObjectView(<span class="string">'/general/extracellular_ephys/electrodes'</span>);

electrode_table_region = types.core.DynamicTableRegion(<span class="string">'table'</span>, ov, <span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'all electrodes'</span>,<span class="keyword">...</span>
    <span class="string">'data'</span>, [1 height(tbl)]');
</pre><p>once you have the <tt>ElectrodeTableRegion</tt> object, you can create an ElectricalSeries object to hold your LFP data. Here is an example using starting_time and rate.</p><pre class="codeinput">electrical_series = types.core.ElectricalSeries(<span class="keyword">...</span>
    <span class="string">'starting_time'</span>, 0.0, <span class="keyword">...</span><span class="comment"> % seconds</span>
    <span class="string">'starting_time_rate'</span>, 200., <span class="keyword">...</span><span class="comment"> % Hz</span>
    <span class="string">'data'</span>, randn(10, 1000),<span class="keyword">...</span>
    <span class="string">'electrodes'</span>, electrode_table_region,<span class="keyword">...</span>
    <span class="string">'data_unit'</span>,<span class="string">'V'</span>);

nwb.acquisition.set(<span class="string">'ECoG'</span>, electrical_series);
</pre><p>You can also specify time using timestamps. This is particularly useful if the timestamps are not evenly sampled. In this case, the electrical series constructor will look like this</p><pre class="codeinput">electrical_series = types.core.ElectricalSeries(<span class="keyword">...</span>
    <span class="string">'timestamps'</span>, (1:1000)/200, <span class="keyword">...</span>
    <span class="string">'starting_time_rate'</span>, 200., <span class="keyword">...</span><span class="comment"> % Hz</span>
    <span class="string">'data'</span>, randn(10, 1000),<span class="keyword">...</span>
    <span class="string">'electrodes'</span>, electrode_table_region,<span class="keyword">...</span>
    <span class="string">'data_unit'</span>,<span class="string">'V'</span>);
</pre><h2 id="10">Trials</h2><p>You can store trial information in the trials table</p><pre class="codeinput">trials = types.core.TimeIntervals( <span class="keyword">...</span>
    <span class="string">'colnames'</span>, {<span class="string">'correct'</span>,<span class="string">'start_time'</span>,<span class="string">'stop_time'</span>},<span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'trial data and properties'</span>, <span class="keyword">...</span>
    <span class="string">'id'</span>, types.core.ElementIdentifiers(<span class="string">'data'</span>, 1:3),<span class="keyword">...</span>
    <span class="string">'start_time'</span>, types.core.VectorData(<span class="string">'data'</span>, [.1, 1.5, 2.5],<span class="keyword">...</span>
        <span class="string">'description'</span>,<span class="string">'hi'</span>),<span class="keyword">...</span>
    <span class="string">'stop_time'</span>, types.core.VectorData(<span class="string">'data'</span>, [1., 2., 3.],<span class="keyword">...</span>
        <span class="string">'description'</span>,<span class="string">'hi'</span>),<span class="keyword">...</span>
    <span class="string">'correct'</span>, types.core.VectorData(<span class="string">'data'</span>, [false,true,false],<span class="keyword">...</span>
        <span class="string">'description'</span>,<span class="string">'my description'</span>));

nwb.intervals.set(<span class="string">'trials'</span>, trials);
</pre><p><tt>colnames</tt> is flexible - it can store any column names and the entries can be any data type, which allows you to store any information you need about trials. The units table stores information about cells and is created with an analogous workflow.</p><h2 id="12">Processing Modules</h2><p>Measurements go in <tt>acquisition</tt> and subject or session data goes in <tt>general</tt>, but if you have the result of an analysis, e.g. spike times, you need to store this in a processing module. Here we make a processing module called "cellular"</p><pre class="codeinput">cell_mod = types.core.ProcessingModule(<span class="string">'description'</span>, <span class="string">'a test module'</span>);
</pre><h2 id="13">Spikes</h2><p>There are two different ways of storing spikes (aka action potentials), <tt>Clustering</tt> and <tt>UnitTimes</tt>. <tt>Clustering</tt> is more strightforward, and is used to mark measured threshold crossings that are spike-sorted into different clusters, indicating that they are believed to come from different neurons. The advantage of this structure is that it is easy to write data via a stream and it is easy to query based on time window (since the timestamps are ordered).</p><pre class="codeinput">spike_times = [0.1, 0.21, 0.34, 0.36, 0.4, 0.43, 0.5, 0.61, 0.66, 0.69];
cluster_ids = [0, 0, 1, 1, 2, 2, 0, 0, 1, 1];

clustering = types.core.Clustering( <span class="keyword">...</span>
    <span class="string">'description'</span>, <span class="string">'my_description'</span>,<span class="keyword">...</span>
    <span class="string">'peak_over_rms'</span>,[1,2,3],<span class="keyword">...</span>
    <span class="string">'times'</span>, spike_times, <span class="keyword">...</span>
    <span class="string">'num'</span>, cluster_ids);

cell_mod.nwbdatainterface.set(<span class="string">'clustering'</span>,clustering);
nwb.processing.set(<span class="string">'cellular'</span>, cell_mod);
</pre><p>The other structure is within the <tt>units</tt> table, which is organized by cell instead of by time. The advantage of <tt>units</tt> is that it is more parallel-friendly. It is easier to split the computation of by cells are read/write in parallel, distributing the cells across the cores of your computation network.</p><p><img vspace="5" hspace="5" src="UnitTimes.png" alt=""> </p><pre class="codeinput">[spike_times_vector, spike_times_index] = util.create_spike_times(cluster_ids, spike_times);
nwb.units = types.core.Units(<span class="string">'colnames'</span>,{<span class="string">'spike_times'</span>,<span class="string">'spike_times_index'</span>},<span class="keyword">...</span>
    <span class="string">'description'</span>,<span class="string">'units table'</span>,<span class="keyword">...</span>
    <span class="string">'id'</span>, types.core.ElementIdentifiers(<span class="string">'data'</span>,1:length(spike_times_index.data)));
nwb.units.spike_times = spike_times_vector;
nwb.units.spike_times_index = spike_times_index;
</pre><h2 id="17">Writing the file</h2><p>Once you have added all of the data types you want to a file, you can save it with the following command</p><pre class="codeinput">nwbExport(nwb, <span class="string">'ecephys_tutorial.nwb'</span>)
</pre><pre class="codeoutput">Warning: Overwriting ecephys_tutorial.nwb 
</pre><h2 id="18">Reading the file</h2><p>load an NWB file object into memory with</p><pre class="codeinput">nwb2 = nwbRead(<span class="string">'ecephys_tutorial.nwb'</span>);
</pre><h2 id="19">Reading data</h2><p>Note that <tt>nwbRead</tt> does <b>not</b> load all of the dataset contained within the file. matnwb automatically supports "lazy read" which means you only read data to memory when you need it, and only read the data you need. Notice the command</p><pre class="codeinput">disp(nwb2.acquisition.get(<span class="string">'ECoG'</span>).data)
</pre><pre class="codeoutput">  DataStub with properties:

    filename: 'ecephys_tutorial.nwb'
        path: '/acquisition/ECoG/data'
        dims: [1000 10]

</pre><p>returns a DataStub object and does not output the values contained in <tt>data</tt>. To get these values, run</p><pre class="codeinput">data = nwb2.acquisition.get(<span class="string">'ECoG'</span>).data.load;
disp(data(1:10, 1:10));
</pre><pre class="codeoutput">  Columns 1 through 7

   -0.6936    0.2240   -1.0878   -1.5047    1.7543    1.5297    0.8051
   -0.8134   -0.9780   -1.0105   -0.9623    0.4165    0.7740   -1.9908
   -0.0844   -0.4668    0.2928    0.6241   -1.6146    0.4207    0.6520
   -2.0610    0.5217   -0.7898    0.5793   -0.4813    0.2765    0.8029
   -1.4875   -0.3337    1.5672   -0.1045    0.2606   -0.6391    0.8795
   -0.4397   -0.8410   -0.5468    1.7624    0.8022   -0.9741    0.5303
   -1.1780   -2.4142    0.4477   -1.7392    0.5812    0.5413    3.9812
    2.8060   -1.4064    1.1881   -2.5787   -0.3850    0.6477   -0.2500
    0.5072    0.7785    0.2314    0.6882   -0.5815    1.0888   -1.1821
   -1.0723    0.9298   -0.2157   -0.5946    1.3987    0.3055    0.6251

  Columns 8 through 10

    1.0078   -0.3963    0.8828
   -0.2236    0.0611    0.1928
    1.0278    1.2719    0.0081
   -0.7277    2.0288   -1.1325
   -0.3218   -0.7245   -0.2870
   -0.3319    0.8852    1.1579
   -0.0737   -0.7908   -0.5727
   -0.8658   -0.2267   -0.6829
   -1.1423    0.4651   -0.4726
    0.3055   -0.7963   -0.6231

</pre><p>Loading all of the data is not a problem for this small dataset, but it can be a problem when dealing with real data that can be several GBs or even TBs per session. In these cases you can load a specific secion of data. For instance, here is how you would load data starting at the index (1,1) and read 10 rows and 20 columns of data</p><pre class="codeinput">nwb2.acquisition.get(<span class="string">'ECoG'</span>).data.load([1,1], [10,20])
</pre><pre class="codeoutput">
ans =

  Columns 1 through 7

   -0.6936    0.2240   -1.0878   -1.5047    1.7543    1.5297    0.8051
   -0.8134   -0.9780   -1.0105   -0.9623    0.4165    0.7740   -1.9908
   -0.0844   -0.4668    0.2928    0.6241   -1.6146    0.4207    0.6520
   -2.0610    0.5217   -0.7898    0.5793   -0.4813    0.2765    0.8029
   -1.4875   -0.3337    1.5672   -0.1045    0.2606   -0.6391    0.8795
   -0.4397   -0.8410   -0.5468    1.7624    0.8022   -0.9741    0.5303
   -1.1780   -2.4142    0.4477   -1.7392    0.5812    0.5413    3.9812
    2.8060   -1.4064    1.1881   -2.5787   -0.3850    0.6477   -0.2500
    0.5072    0.7785    0.2314    0.6882   -0.5815    1.0888   -1.1821
   -1.0723    0.9298   -0.2157   -0.5946    1.3987    0.3055    0.6251

  Columns 8 through 14

    1.0078   -0.3963    0.8828   -0.1250    0.0551   -2.5611   -0.4218
   -0.2236    0.0611    0.1928    0.5603    0.4039    0.4784    0.1730
    1.0278    1.2719    0.0081   -1.0298   -1.0056   -1.8454   -0.4532
   -0.7277    2.0288   -1.1325   -0.1076    0.1223    0.6692    0.0406
   -0.3218   -0.7245   -0.2870    0.7564   -2.0511    0.3506   -2.0201
   -0.3319    0.8852    1.1579    0.1048    1.1934    0.3792    0.5551
   -0.0737   -0.7908   -0.5727   -0.1828   -1.0185   -1.0451    1.7513
   -0.8658   -0.2267   -0.6829    0.4321   -0.8856   -2.5323   -1.0021
   -1.1423    0.4651   -0.4726    0.9816   -0.0088   -1.3650   -0.5839
    0.3055   -0.7963   -0.6231   -0.7966    0.0154   -1.9234    0.3494

  Columns 15 through 20

    0.3587   -0.0430    0.9137   -0.1743    0.7064    0.5040
    1.4069    1.3652   -1.3192   -1.3934    1.2479    0.6959
   -1.1303   -0.7657    0.4718   -0.8550   -1.2778   -0.1092
   -1.2370   -0.1967    0.3083    1.4092    0.6678    0.0654
   -2.0317   -1.3768    0.4908    0.0017   -0.9617    1.4020
   -1.5357    0.4171    1.1704    0.5469    0.0140    2.2483
    0.6528    0.2167    0.1978   -0.4496   -2.1267   -0.8044
   -0.0282   -1.3720    1.5665   -1.0852   -0.1533   -0.8188
    0.7882   -0.0916   -0.3588    0.1688    0.7479    0.8679
    1.7643    0.7474   -1.3854    0.7336    0.0287   -1.7593

</pre><p>run <tt>doc('types.untyped.DataStub')</tt> for more details on manual partial loading. There are several convenience functions that make common data loading patterns easier. The following convenience function loads data for all trials</p><pre class="codeinput"><span class="comment">% data from .05 seconds before and half a second after start of each trial</span>
window = [-.05, 0.5]; <span class="comment">% seconds</span>

<span class="comment">% only data where the attribute 'correct' == 0</span>
conditions = containers.Map(<span class="string">'correct'</span>, 0);

<span class="comment">% get ECoG data</span>
timeseries = nwb2.acquisition.get(<span class="string">'ECoG'</span>);

[trial_data, tt] = util.loadTrialAlignedTimeSeriesData(nwb2, <span class="keyword">...</span>
    timeseries, window, conditions);

<span class="comment">% plot data from the first electrode for those two trials (it's just noise in this example)</span>
plot(tt, squeeze(trial_data(:,1,:)))
xlabel(<span class="string">'time (seconds)'</span>)
ylabel([<span class="string">'ECoG ('</span> timeseries.data_unit <span class="string">')'</span>])
</pre><img vspace="5" hspace="5" src="ecephys_01.png" alt=""> <h2 id="23">Reading UnitTimes (RegionViews)</h2><p><tt>UnitTimes</tt> uses RegionViews to indicate which spikes belong to which cell. The structure is split up into 3 datasets (see Spikes secion):</p><pre class="codeinput">my_spike_times = nwb.units.spike_times;
</pre><p>To get the data for cell 1, first determine the uid that equals 1.</p><pre class="codeinput">select = nwb.units.id.data == 1
</pre><pre class="codeoutput">
select =

  1&times;3 logical array

   1   0   0

</pre><p>Then select the corresponding spike_times_index element</p><pre class="codeinput">my_index = nwb.units.spike_times_index.data(select)
</pre><pre class="codeoutput">
my_index = 

  RegionView with properties:

      path: '/units/spike_times'
      view: [1&times;1 types.untyped.ObjectView]
    region: {[2&times;1 double]}

</pre><p>Finally, access the data that the view points to using <tt>refresh</tt></p><pre class="codeinput">my_index.refresh(nwb)
</pre><pre class="codeoutput">
ans =

    0.1000    0.2100    0.5000    0.6100

</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Neurodata Without Borders: Neurophysiology (NWB:N), Extracellular Electrophysiology Tutorial
% How to write ecephys data to an NWB file using matnwb.
% 
%  author: Ben Dichter
%  contact: ben.dichter@gmail.com
%  last edited: Oct 9, 2018

%% NWB file
% All contents get added to the NWB file, which is created with the
% following command

date = datetime(2018, 3, 1, 12, 0, 0);
session_start_time = datetime(date,'Format','yyyy-MM-dd''T''HH:mm:SSZZ',...
    'TimeZone','local');
nwb = nwbfile( 'source', 'acquired on rig2', ...
    'session_description', 'a test NWB File', ...
    'identifier', 'mouse004_day4', ...
    'session_start_time', session_start_time);

%%
% You can check the contents by displaying the nwbfile object
disp(nwb);

%% Data dependencies
% The data needs to be added to nwb in a specific order, which is specified
% by the data dependencies in the schema. The data dependencies for LFP are
% illustrated in the following diagram. In order to write LFP, you need to 
% specify what electrodes it came from. To do that, you first need to 
% construct an electrode table. 
%%
% 
% <<ecephys_data_deps.png>>
% 

%% Electrode Table
% Electrode tables hold the position and group information about each 
% electrode and the brain region and filtering. Groups organize electrodes 
% within a single device. Devices can have 1 or more groups. In this example, 
% we have 2 devices that each only have a single group.

device_labels = {'a','a','a','a','a','b','b','b','b','b'};

udevice_labels = unique(device_labels, 'stable');

variables = {'id', 'x', 'y', 'z', 'imp', 'location', 'filtering', ...
    'group', 'group_name'};
for i_device = 1:length(udevice_labels)
    device_label = udevice_labels{i_device};
    
    nwb.general_devices.set(device_label,...
        types.core.Device());
    
    nwb.general_extracellular_ephys.set(device_label,...
        types.core.ElectrodeGroup(...
        'description', 'a test ElectrodeGroup', ...
        'location', 'unknown', ...
        'device', types.untyped.SoftLink(['/general/devices/' device_label])));
    
    ov = types.untyped.ObjectView(['/general/extracellular_ephys/' device_label]);
    
    elec_nums = find(strcmp(device_labels, device_label));
    for i_elec = 1:length(elec_nums)
        elec_num = elec_nums(i_elec);
        if i_device == 1 && i_elec == 1
            tbl = table(int64(1), NaN, NaN, NaN, NaN, {'CA1'}, {'filtering'}...
                , ov, {'electrode_group'},'VariableNames', variables);
        else
            tbl = [tbl; {int64(elec_num), NaN, NaN, NaN, NaN,...
                'CA1', 'filtering', ov, 'electrode_group'}];
        end
    end        
end
%%
% add the |DynamicTable| object to the NWB file using the name |'electrodes'| (not flexible)

tbl.Properties.Description = 'my description';

electrode_table = util.table2nwb(tbl);
nwb.general_extracellular_ephys.set('electrodes', electrode_table);

%% LFP
% In order to write LFP, you need to construct a region view of the electrode 
% table to link the signal to the electrodes that generated them. You must do
% this even if the signal is from all of the electrodes. Here we will create
% a reference that includes all electrodes. Then we will randomly generate a
% signal 1000 timepoints long from 10 channels

ov = types.untyped.ObjectView('/general/extracellular_ephys/electrodes');

electrode_table_region = types.core.DynamicTableRegion('table', ov, ...
    'description', 'all electrodes',...
    'data', [1 height(tbl)]');

%%
% once you have the |ElectrodeTableRegion| object, you can create an
% ElectricalSeries object to hold your LFP data. Here is an example using
% starting_time and rate.

electrical_series = types.core.ElectricalSeries(...
    'starting_time', 0.0, ... % seconds
    'starting_time_rate', 200., ... % Hz
    'data', randn(10, 1000),...
    'electrodes', electrode_table_region,...
    'data_unit','V');

nwb.acquisition.set('ECoG', electrical_series);
%%
% You can also specify time using timestamps. This is particularly useful if
% the timestamps are not evenly sampled. In this case, the electrical series
% constructor will look like this

electrical_series = types.core.ElectricalSeries(...
    'timestamps', (1:1000)/200, ...
    'starting_time_rate', 200., ... % Hz
    'data', randn(10, 1000),...
    'electrodes', electrode_table_region,...
    'data_unit','V');

%% Trials
% You can store trial information in the trials table

trials = types.core.TimeIntervals( ...
    'colnames', {'correct','start_time','stop_time'},...
    'description', 'trial data and properties', ...
    'id', types.core.ElementIdentifiers('data', 1:3),...
    'start_time', types.core.VectorData('data', [.1, 1.5, 2.5],...
        'description','hi'),...
    'stop_time', types.core.VectorData('data', [1., 2., 3.],...
        'description','hi'),...
    'correct', types.core.VectorData('data', [false,true,false],...
        'description','my description'));

nwb.intervals.set('trials', trials);

%%
% |colnames| is flexible - it can store any column names and the entries can
% be any data type, which allows you to store any information you need about 
% trials. The units table stores information about cells and is created with
% an analogous workflow.

%% Processing Modules
% Measurements go in |acquisition| and subject or session data goes in
% |general|, but if you have the result of an analysis, e.g. spike times,
% you need to store this in a processing module. Here we make a processing
% module called "cellular"

cell_mod = types.core.ProcessingModule('description', 'a test module');

%% Spikes
% There are two different ways of storing spikes (aka action potentials),
% |Clustering| and |UnitTimes|. |Clustering| is more strightforward, and is used to mark
% measured threshold crossings that are spike-sorted into different clusters,
% indicating that they are believed to come from different neurons. The
% advantage of this structure is that it is easy to write data via a stream
% and it is easy to query based on time window (since the timestamps are 
% ordered).

spike_times = [0.1, 0.21, 0.34, 0.36, 0.4, 0.43, 0.5, 0.61, 0.66, 0.69];
cluster_ids = [0, 0, 1, 1, 2, 2, 0, 0, 1, 1];

clustering = types.core.Clustering( ...
    'description', 'my_description',...
    'peak_over_rms',[1,2,3],...
    'times', spike_times, ...
    'num', cluster_ids);

cell_mod.nwbdatainterface.set('clustering',clustering);
nwb.processing.set('cellular', cell_mod);

%%
% The other structure is within the |units| table, which is organized by cell instead of
% by time. The advantage of |units| is that it is more
% parallel-friendly. It is easier to split the computation of by cells are
% read/write in parallel, distributing the cells across the cores of your
% computation network.
%%
% 
% <<UnitTimes.png>>
% 
%%

[spike_times_vector, spike_times_index] = util.create_spike_times(cluster_ids, spike_times);
nwb.units = types.core.Units('colnames',{'spike_times','spike_times_index'},...
    'description','units table',...
    'id', types.core.ElementIdentifiers('data',1:length(spike_times_index.data)));
nwb.units.spike_times = spike_times_vector;
nwb.units.spike_times_index = spike_times_index;


%% Writing the file
% Once you have added all of the data types you want to a file, you can save
% it with the following command

nwbExport(nwb, 'ecephys_tutorial.nwb')

%% Reading the file
% load an NWB file object into memory with

nwb2 = nwbRead('ecephys_tutorial.nwb');

%% Reading data
% Note that |nwbRead| does *not* load all of the dataset contained 
% within the file. matnwb automatically supports "lazy read" which means
% you only read data to memory when you need it, and only read the data you
% need. Notice the command

disp(nwb2.acquisition.get('ECoG').data)

%%
% returns a DataStub object and does not output the values contained in 
% |data|. To get these values, run

data = nwb2.acquisition.get('ECoG').data.load;
disp(data(1:10, 1:10));

%%
% Loading all of the data is not a problem for this small
% dataset, but it can be a problem when dealing with real data that can be
% several GBs or even TBs per session. In these cases you can load a specific secion of
% data. For instance, here is how you would load data starting at the index
% (1,1) and read 10 rows and 20 columns of data

nwb2.acquisition.get('ECoG').data.load([1,1], [10,20])

%%
% run |doc('types.untyped.DataStub')| for more details on manual partial
% loading. There are several convenience functions that make common data
% loading patterns easier. The following convenience function loads data 
% for all trials

% data from .05 seconds before and half a second after start of each trial
window = [-.05, 0.5]; % seconds

% only data where the attribute 'correct' == 0
conditions = containers.Map('correct', 0);

% get ECoG data
timeseries = nwb2.acquisition.get('ECoG');

[trial_data, tt] = util.loadTrialAlignedTimeSeriesData(nwb2, ...
    timeseries, window, conditions);

% plot data from the first electrode for those two trials (it's just noise in this example)
plot(tt, squeeze(trial_data(:,1,:)))
xlabel('time (seconds)')
ylabel(['ECoG (' timeseries.data_unit ')'])

%% Reading UnitTimes (RegionViews)
% |UnitTimes| uses RegionViews to indicate which spikes belong to which cell.
% The structure is split up into 3 datasets (see Spikes secion):
my_spike_times = nwb.units.spike_times;
%%
% To get the data for cell 1, first determine the uid that equals 1.
select = nwb.units.id.data == 1
%%
% Then select the corresponding spike_times_index element
my_index = nwb.units.spike_times_index.data(select)
%%
% Finally, access the data that the view points to using |refresh|
my_index.refresh(nwb)

##### SOURCE END #####
--></body></html>